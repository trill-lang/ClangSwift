/// IMPORTANT: This file is automatically generated.
#if SWIFT_PACKAGE
  import cclang
#endif

/// MARK: Customized Types

internal protocol FunctionLikeDecl: ClangCursorBacked {}

public struct FunctionDecl: ClangCursorBacked {
  let clang: CXCursor
  
  init(clang: CXCursor) {
    self.clang = clang
  }

  /// Retrieve the number of arguments of the function.
  public var argumentCount: Int {
    return Int(clang_Cursor_getNumArguments(clang))
  }
  
  /// Retrieve the argument cursor of a function or method.
  /// The argument cursor can be determined for calls as well as for
  /// declarations of functions or methods.
  public func parameter(at index: Int) -> Cursor? {
    return convertCursor(clang_Cursor_getArgument(clang, UInt32(index)))
  }
  
  /// Retrieve the return type of the function.
  public var resultType: CType? {
    return convertType(clang_getCursorResultType(clang))
  }

  /// Tells if the function declaration is inlined.
  public var isInlined: Bool {
    return clang_Cursor_isFunctionInlined(clang) != 0
  }
}

protocol MethodDecl: ClangCursorBacked {}
extension MethodDecl {
  
  /// Determine the set of methods that are overridden by the given method.
  /// In both Objective-C and C++, a method (aka virtual member function, in
  /// C++) can override a virtual method in a base class. For Objective-C, a
  /// method is said to override any method in the class's base class, its
  /// protocols, or its categories' protocols, that has the same selector and
  /// is of the same kind (class or instance). If no such method exists, the
  /// search continues to the class's superclass, its protocols, and its
  /// categories, and so on. A method from an Objective-C implementation is
  /// considered to override the same methods as its corresponding method in
  /// the interface.
  ///
  /// For C++, a virtual member function overrides any virtual member function
  /// with the same signature that occurs in its base classes. With multiple
  /// inheritance, a virtual member function can override several virtual
  /// member functions coming from different base classes.
  ///
  /// In all cases, this will return the immediate overridden method,
  /// rather than all of the overridden methods. For example, if a method is
  /// originally declared in a class A, then overridden in B (which in
  /// inherits from A) and also in C (which inherited from B), then the only
  /// overridden method returned from this function when invoked on C's method
  /// will be B's method. The client may then invoke this function again,
  /// given the previously-found overridden methods, to map out the complete
  /// method-override set.
  public var overrides: [Cursor] {
    var overridden: UnsafeMutablePointer<CXCursor>?
    var overrideCount = 0 as UInt32
    clang_getOverriddenCursors(clang, &overridden, &overrideCount)
    guard let overriddenPtr = overridden else { return [] }
    var overrides = [Cursor]()
    for i in 0..<Int(overrideCount) {
      if let cursor = convertCursor(overriddenPtr[i]) {
        overrides.append(cursor)
      }
    }
    clang_disposeOverriddenCursors(overridden)
    return overrides
  }
}

/// A `#include` directive.
public struct InclusionDirective: ClangCursorBacked {
  let clang: CXCursor
  
  /// Retrieve the file that is included by the given inclusion directive.
  public var includedFile: File? {
    return File(clang: clang_getIncludedFile(asClang()))
  }
}

/// Common protocol for "record types", i.e. structs, classes, and Objective-C
/// classes.
protocol RecordDecl: ClangCursorBacked {}
extension RecordDecl {
  /// Retrieves an array of all the fields of this record type.
  public func fields() -> [Cursor] {
    guard let type = type as? RecordType else { return [] }
    return type.fields()
  }
}

public struct StructDecl: RecordDecl {
  let clang: CXCursor
}

public struct ClassDecl: RecordDecl {
  let clang: CXCursor
}

public struct EnumConstantDecl: ClangCursorBacked {
  let clang: CXCursor
  
  /// Retrieve the integer value of an enum constant declaration as an `Int`.
  public var value: Int {
    return Int(clang_getEnumConstantDeclValue(clang))
  }
  
  /// Retrieve the integer value of an enum constant declaration as a `UInt`.
  public var unsignedValue: UInt {
    return UInt(clang_getEnumConstantDeclUnsignedValue(clang))
  }
}

protocol MacroCursor: ClangCursorBacked {}
extension MacroCursor {
  /// Determine whether a macro is function like.
  public var isFunctionLike: Bool {
    return clang_Cursor_isMacroFunctionLike(clang) != 0
  }
  
  /// Determine whether a macro is a built-in macro.
  public var isBuiltin: Bool {
    return clang_Cursor_isMacroBuiltin(clang) != 0
  }
}
public struct MacroExpansion: MacroCursor {
  let clang: CXCursor
}

public struct MacroInstantiation: MacroCursor {
  let clang: CXCursor
}

public struct MacroDefinition: MacroCursor {
  let clang: CXCursor
}

/// An access specifier.
public struct CXXAccessSpecifier: ClangCursorBacked {
  let clang: CXCursor
}

public struct EnumDecl: ClangCursorBacked {
  let clang: CXCursor
  
  /// Retrieves an array of all the constants as part of this enum.
  public func constants() -> [EnumConstantDecl] {
    return children() as! [EnumConstantDecl]
  }
  
  /// Retrieve the integer type of an enum declaration.
  public var integerType: CType {
    return convertType(clang_getEnumDeclIntegerType(clang))!
  }
}

protocol TypeAliasCursor: ClangCursorBacked {}
extension TypeAliasCursor {
  /// Retrieve the underlying type of a typedef declaration.
  public var underlying: CType? {
    return convertType(clang_getTypedefDeclUnderlyingType(clang))
  }
}

public struct TypedefDecl: TypeAliasCursor { let clang: CXCursor }
public struct TypeAliasDecl: TypeAliasCursor { let clang: CXCursor }
public struct UsingDirective: TypeAliasCursor { let clang: CXCursor }
public struct UsingDeclaration: TypeAliasCursor { let clang: CXCursor }

/// MARK: Standard Types

/// Unexposed declarations have the same operations as any other kind of
/// declaration; one can extract their location information, spelling, find
/// their definitions, etc. However, the specific kind of the declaration is not
/// reported.
/// A declaration whose specific kind is not exposed via this interface.
public struct UnexposedDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A C or C++ union.
public struct UnionDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A field (in C) or non-static data member (in C++) in a struct, union, or C++
/// class.
public struct FieldDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A variable.
public struct VarDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A function or method parameter.
public struct ParmDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @interface.
public struct ObjCInterfaceDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @interface for a category.
public struct ObjCCategoryDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @protocol declaration.
public struct ObjCProtocolDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @property declaration.
public struct ObjCPropertyDecl: ClangCursorBacked {
  let clang: CXCursor
  
  public var attributes: ObjCPropertyAttributes {
    return ObjCPropertyAttributes(rawValue:
      clang_Cursor_getObjCPropertyAttributes(clang, 0))
  }
}

/// An Objective-C instance variable.
public struct ObjCIvarDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C instance method.
public struct ObjCInstanceMethodDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C class method.
public struct ObjCClassMethodDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @implementation.
public struct ObjCImplementationDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @implementation for a category.
public struct ObjCCategoryImplDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ class method.
public struct CXXMethod: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ namespace.
public struct Namespace: ClangCursorBacked {
  let clang: CXCursor
}

/// A linkage specification, e.g. 'extern "C"'.
public struct LinkageSpec: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ constructor.
public struct Constructor: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ destructor.
public struct Destructor: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ conversion function.
public struct ConversionFunction: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ template type parameter.
public struct TemplateTypeParameter: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ non-type template parameter.
public struct NonTypeTemplateParameter: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ template template parameter.
public struct TemplateTemplateParameter: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ function template.
public struct FunctionTemplate: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ class template.
public struct ClassTemplate: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ class template partial specialization.
public struct ClassTemplatePartialSpecialization: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ namespace alias declaration.
public struct NamespaceAlias: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @synthesize definition.
public struct ObjCSynthesizeDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @dynamic definition.
public struct ObjCDynamicDecl: ClangCursorBacked {
  let clang: CXCursor
}

public struct ObjCSuperClassRef: ClangCursorBacked {
  let clang: CXCursor
}

public struct ObjCProtocolRef: ClangCursorBacked {
  let clang: CXCursor
}

public struct ObjCClassRef: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a type declaration.
/// A type reference occurs anywhere where a type is named but not declared. For
/// example, given:
/// ```
/// typedef unsigned size_type;
/// size_type size;
/// ```
/// The typedef is a declaration of size_type (CXCursor_TypedefDecl), while the
/// type of the variable "size" is referenced. The cursor referenced by the type
/// of size is the typedef for size_type.
public struct TypeRef: ClangCursorBacked {
  let clang: CXCursor
}

public struct CXXBaseSpecifier: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a class template, function template, template
/// parameter, or class template partial specialization.
public struct TemplateRef: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a namespace or namespace alias.
public struct NamespaceRef: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a member of a struct, union, or class that occurs in some
/// non-expression context, e.g., a designated initializer.
public struct MemberRef: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a labeled statement.
/// This cursor kind is used to describe the jump to "start_over" in the goto
/// statement in the following example:
/// ```
/// start_over:
/// ++counter;
///
/// goto start_over;
/// ```
/// A label reference cursor refers to a label statement.
public struct LabelRef: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a set of overloaded functions or function templates that has
/// not yet been resolved to a specific function or function template.
/// An overloaded declaration reference cursor occurs in C++ templates where a
/// dependent name refers to a function. For example:
/// ```
/// template<typename T> void swap(T&, T&);
///
/// struct Y { };
/// void swap(Y&, Y&);
/// ```
/// Here, the identifier "swap" is associated with an overloaded declaration
/// reference. In the template definition, "swap" refers to either of the two
/// "swap" functions declared above, so both results will be available. At
/// instantiation time, "swap" may also refer to other functions found via
/// argument-dependent lookup (e.g., the "swap" function at the end of the
/// example).
public struct OverloadedDeclRef: ClangCursorBacked {
  let clang: CXCursor
}

/// A reference to a variable that occurs in some non-expression context, e.g.,
/// a C++ lambda capture list.
public struct VariableRef: ClangCursorBacked {
  let clang: CXCursor
}

public struct InvalidFile: ClangCursorBacked {
  let clang: CXCursor
}

public struct NoDeclFound: ClangCursorBacked {
  let clang: CXCursor
}

public struct NotImplemented: ClangCursorBacked {
  let clang: CXCursor
}

public struct InvalidCode: ClangCursorBacked {
  let clang: CXCursor
}

/// An expression whose specific kind is not exposed via this interface.
/// Unexposed expressions have the same operations as any other kind of
/// expression; one can extract their location information, spelling, children,
/// etc. However, the specific kind of the expression is not reported.
public struct UnexposedExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An expression that refers to some value declaration, such as a function,
/// variable, or enumerator.
public struct DeclRefExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An expression that refers to a member of a struct, union, class, Objective-C
/// class, etc.
public struct MemberRefExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An expression that calls a function.
public struct CallExpr: ClangCursorBacked {
  let clang: CXCursor
  
  /// Retrieve the argument cursor of a function or method.
  /// The argument cursor can be determined for calls as well as for
  /// declarations of functions or methods.
  public func parameter(at index: Int) -> Cursor? {
    return convertCursor(clang_Cursor_getArgument(clang, UInt32(index)))
  }
  
  /// Retrieve the return type of the function.
  public var resultType: CType? {
    return convertType(clang_getCursorResultType(clang))
  }
}

/// An expression that sends a message to an Objective-C object or class.
public struct ObjCMessageExpr: ClangCursorBacked {
  let clang: CXCursor
  
  /// Retrieve the argument cursor of a function or method.
  /// The argument cursor can be determined for calls as well as for
  /// declarations of functions or methods.
  public func parameter(at index: Int) -> Cursor? {
    return convertCursor(clang_Cursor_getArgument(clang, UInt32(index)))
  }
  
  /// Retrieve the return type of the function.
  public var resultType: CType? {
    return convertType(clang_getCursorResultType(clang))
  }
}

/// An expression that represents a block literal.
public struct BlockExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An integer literal.
public struct IntegerLiteral: ClangCursorBacked {
  let clang: CXCursor
}

/// A floating point number literal.
public struct FloatingLiteral: ClangCursorBacked {
  let clang: CXCursor
}

/// An imaginary number literal.
public struct ImaginaryLiteral: ClangCursorBacked {
  let clang: CXCursor
}

/// A string literal.
public struct StringLiteral: ClangCursorBacked {
  let clang: CXCursor
}

/// A character literal.
public struct CharacterLiteral: ClangCursorBacked {
  let clang: CXCursor
}

/// A parenthesized expression, e.g. "(1)".
/// - note: This AST node is only formed if full location information is
///         requested.
public struct ParenExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// This represents the unary-expression's (except sizeof and alignof).
public struct UnaryOperator: ClangCursorBacked {
  let clang: CXCursor
}

/// [C99 6.5.2.1] Array Subscripting.
public struct ArraySubscriptExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// A builtin binary operation expression such as "x + y" or "x <= y".
public struct BinaryOperator: ClangCursorBacked {
  let clang: CXCursor
}

/// Compound assignment such as "+=".
public struct CompoundAssignOperator: ClangCursorBacked {
  let clang: CXCursor
}

/// The ?: ternary operator.
public struct ConditionalOperator: ClangCursorBacked {
  let clang: CXCursor
}

/// An explicit cast in C (C99 6.5.4) or a C-style cast in C++ (C++
/// [expr.cast]), which uses the syntax (Type)expr.
/// For example: `(int)f`.
public struct CStyleCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// [C99 6.5.2.5]
public struct CompoundLiteralExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Describes an C or C++ initializer list.
public struct InitListExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// The GNU address of label extension, representing &&label.
public struct AddrLabelExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// This is the GNU Statement Expression extension: ({int X=4; X;})
public struct StmtExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents a C11 generic selection.
public struct GenericSelectionExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Implements the GNU `__null` extension, which is a name for a null pointer
/// constant that has integral type (e.g., int or long) and is the same size and
/// alignment as a pointer.
/// The `__null extension` is typically only used by system headers, which define
/// `NULL` as `__null` in C++ rather than using 0 (which is an integer that may
/// not match the size of a pointer).
public struct GNUNullExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s static_cast<> expression.
public struct CXXStaticCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s dynamic_cast<> expression.
public struct CXXDynamicCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s reinterpret_cast<> expression.
public struct CXXReinterpretCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s const_cast<> expression.
public struct CXXConstCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents an explicit C++ type conversion that uses "functional" notion
/// (C++ [expr.type.conv]).
/// Example:
/// ```
/// x = int(0.5);
/// ```
public struct CXXFunctionalCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// A C++ typeid expression (C++ [expr.typeid]).
public struct CXXTypeidExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// [C++ 2.13.5] C++ Boolean Literal.
public struct CXXBoolLiteralExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// [C++0x 2.14.7] C++ Pointer Literal.
public struct CXXNullPtrLiteralExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents the "this" expression in C++
public struct CXXThisExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// This handles 'throw' and 'throw' assignment-expression. When
/// assignment-expression isn't present, Op will be null.
/// [C++ 15] C++ Throw Expression.
public struct CXXThrowExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// A new expression for memory allocation and constructor calls, e.g: "new
/// CXXNewExpr(foo)".
public struct CXXNewExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// A delete expression for memory deallocation and destructor calls, e.g.
/// "delete[] pArray".
public struct CXXDeleteExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// A unary expression. (noexcept, sizeof, or other traits)
public struct UnaryExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C string literal i.e. "foo".
public struct ObjCStringLiteral: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @encode expression.
public struct ObjCEncodeExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @selector expression.
public struct ObjCSelectorExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C @protocol expression.
public struct ObjCProtocolExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// An Objective-C "bridged" cast expression, which casts between Objective-C
/// pointers and C pointers, transferring ownership in the process.
/// ```
/// NSString *str = (__bridge_transfer NSString *)CFCreateString();
/// ```
public struct ObjCBridgedCastExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents a C++0x pack expansion that produces a sequence of expressions.
/// A pack expansion expression contains a pattern (which itself is an
/// expression) followed by an ellipsis. For example:
/// ```
/// template<typename F, typename ...Types>
/// void forward(F f, Types &&...args) {
/// f(static_cast<Types&&>(args)...);
/// }
/// ```
public struct PackExpansionExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents an expression that computes the length of a parameter pack.
/// ```
/// template<typename ...Types>
/// struct count {
/// static const unsigned value = sizeof...(Types);
/// };
/// ```
public struct SizeOfPackExpr: ClangCursorBacked {
  let clang: CXCursor
}

public struct LambdaExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-c Boolean Literal.
public struct ObjCBoolLiteralExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents the "self" expression in an Objective-C method.
public struct ObjCSelfExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP 4.0 [2.4, Array Section].
public struct OMPArraySectionExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Represents an @available(...) check.
public struct ObjCAvailabilityCheckExpr: ClangCursorBacked {
  let clang: CXCursor
}

/// Unexposed statements have the same operations as any other kind of
/// statement; one can extract their location information, spelling, children,
/// etc. However, the specific kind of the statement is not reported.
/// A statement whose specific kind is not exposed via this interface.
public struct UnexposedStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A labelled statement in a function.
/// This cursor kind is used to describe the "start_over:" label statement in
/// the following example:
/// ```
/// start_over:
/// ++counter;
/// ```
public struct LabelStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A group of statements like { stmt stmt }.
/// This cursor kind is used to describe compound statements, e.g. function
/// bodies.
public struct CompoundStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A case statement.
public struct CaseStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A default statement.
public struct DefaultStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// An if statement
public struct IfStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A switch statement.
public struct SwitchStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A while statement.
public struct WhileStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A do statement.
public struct DoStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A for statement.
public struct ForStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A goto statement.
public struct GotoStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// An indirect goto statement.
public struct IndirectGotoStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A continue statement.
public struct ContinueStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A break statement.
public struct BreakStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A return statement.
public struct ReturnStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A GCC inline assembly statement extension.
public struct GCCAsmStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A GCC inline assembly statement extension.
public struct AsmStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's overall @try-@catch-@finally statement.
public struct ObjCAtTryStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's @catch statement.
public struct ObjCAtCatchStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's @finally statement.
public struct ObjCAtFinallyStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's @throw statement.
public struct ObjCAtThrowStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's @synchronized statement.
public struct ObjCAtSynchronizedStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's autorelease pool statement.
public struct ObjCAutoreleasePoolStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Objective-C's collection statement.
public struct ObjCForCollectionStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s catch statement.
public struct CXXCatchStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s try statement.
public struct CXXTryStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// C++'s for (* : *) statement.
public struct CXXForRangeStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Windows Structured Exception Handling's try statement.
public struct SEHTryStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Windows Structured Exception Handling's except statement.
public struct SEHExceptStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Windows Structured Exception Handling's finally statement.
public struct SEHFinallyStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// A MS inline assembly statement extension.
public struct MSAsmStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// This cursor kind is used to describe the null statement.
/// The null statement ";": C99 6.8.3p3.
public struct NullStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// Adaptor class for mixing declarations with statements and expressions.
public struct DeclStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP parallel directive.
public struct OMPParallelDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP SIMD directive.
public struct OMPSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP for directive.
public struct OMPForDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP sections directive.
public struct OMPSectionsDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP section directive.
public struct OMPSectionDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP single directive.
public struct OMPSingleDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP parallel for directive.
public struct OMPParallelForDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP parallel sections directive.
public struct OMPParallelSectionsDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP task directive.
public struct OMPTaskDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP master directive.
public struct OMPMasterDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP critical directive.
public struct OMPCriticalDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP taskyield directive.
public struct OMPTaskyieldDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP barrier directive.
public struct OMPBarrierDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP taskwait directive.
public struct OMPTaskwaitDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP flush directive.
public struct OMPFlushDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// Windows Structured Exception Handling's leave statement.
public struct SEHLeaveStmt: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP ordered directive.
public struct OMPOrderedDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP atomic directive.
public struct OMPAtomicDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP for SIMD directive.
public struct OMPForSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP parallel for SIMD directive.
public struct OMPParallelForSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target directive.
public struct OMPTargetDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP teams directive.
public struct OMPTeamsDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP taskgroup directive.
public struct OMPTaskgroupDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP cancellation point directive.
public struct OMPCancellationPointDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP cancel directive.
public struct OMPCancelDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target data directive.
public struct OMPTargetDataDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP taskloop directive.
public struct OMPTaskLoopDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP taskloop simd directive.
public struct OMPTaskLoopSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP distribute directive.
public struct OMPDistributeDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target enter data directive.
public struct OMPTargetEnterDataDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target exit data directive.
public struct OMPTargetExitDataDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target parallel directive.
public struct OMPTargetParallelDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target parallel for directive.
public struct OMPTargetParallelForDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target update directive.
public struct OMPTargetUpdateDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP distribute parallel for directive.
public struct OMPDistributeParallelForDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP distribute parallel for simd directive.
public struct OMPDistributeParallelForSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP distribute simd directive.
public struct OMPDistributeSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// OpenMP target parallel for simd directive.
public struct OMPTargetParallelForSimdDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// Cursor that represents the translation unit itself.
/// The translation unit cursor exists primarily to act as the root cursor for
/// traversing the contents of a translation unit.
public struct TranslationUnitCursor: ClangCursorBacked {
  let clang: CXCursor
}


public struct UnexposedAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct IBActionAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct IBOutletAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct IBOutletCollectionAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CXXFinalAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CXXOverrideAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct AnnotateAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct AsmLabelAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct PackedAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct PureAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct ConstAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct NoDuplicateAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CUDAConstantAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CUDADeviceAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CUDAGlobalAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CUDAHostAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct CUDASharedAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct VisibilityAttr: ClangCursorBacked {
  let clang: CXCursor
}


public struct DLLExport: ClangCursorBacked {
  let clang: CXCursor
}


public struct DLLImport: ClangCursorBacked {
  let clang: CXCursor
}


public struct PreprocessingDirective: ClangCursorBacked {
  let clang: CXCursor
}

/// A module import declaration.
public struct ModuleImportDecl: ClangCursorBacked {
  let clang: CXCursor
}

public struct TypeAliasTemplateDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A static_assert or _Static_assert node
public struct StaticAssert: ClangCursorBacked {
  let clang: CXCursor
}

/// A friend declaration.
public struct FriendDecl: ClangCursorBacked {
  let clang: CXCursor
}

/// A code completion overload candidate.
public struct OverloadCandidate: ClangCursorBacked {
  let clang: CXCursor
}

/// Converts a CXCursor to a Cursor, returning `nil` if it was unsuccessful
func convertCursor(_ clang: CXCursor) -> Cursor? {
  if clang_Cursor_isNull(clang) != 0 { return nil }
  switch clang.kind {
  case CXCursor_UnexposedDecl: return UnexposedDecl(clang: clang)
  case CXCursor_StructDecl: return StructDecl(clang: clang)
  case CXCursor_UnionDecl: return UnionDecl(clang: clang)
  case CXCursor_ClassDecl: return ClassDecl(clang: clang)
  case CXCursor_EnumDecl: return EnumDecl(clang: clang)
  case CXCursor_FieldDecl: return FieldDecl(clang: clang)
  case CXCursor_EnumConstantDecl: return EnumConstantDecl(clang: clang)
  case CXCursor_FunctionDecl: return FunctionDecl(clang: clang)
  case CXCursor_VarDecl: return VarDecl(clang: clang)
  case CXCursor_ParmDecl: return ParmDecl(clang: clang)
  case CXCursor_ObjCInterfaceDecl: return ObjCInterfaceDecl(clang: clang)
  case CXCursor_ObjCCategoryDecl: return ObjCCategoryDecl(clang: clang)
  case CXCursor_ObjCProtocolDecl: return ObjCProtocolDecl(clang: clang)
  case CXCursor_ObjCPropertyDecl: return ObjCPropertyDecl(clang: clang)
  case CXCursor_ObjCIvarDecl: return ObjCIvarDecl(clang: clang)
  case CXCursor_ObjCInstanceMethodDecl: return ObjCInstanceMethodDecl(clang: clang)
  case CXCursor_ObjCClassMethodDecl: return ObjCClassMethodDecl(clang: clang)
  case CXCursor_ObjCImplementationDecl: return ObjCImplementationDecl(clang: clang)
  case CXCursor_ObjCCategoryImplDecl: return ObjCCategoryImplDecl(clang: clang)
  case CXCursor_TypedefDecl: return TypedefDecl(clang: clang)
  case CXCursor_CXXMethod: return CXXMethod(clang: clang)
  case CXCursor_Namespace: return Namespace(clang: clang)
  case CXCursor_LinkageSpec: return LinkageSpec(clang: clang)
  case CXCursor_Constructor: return Constructor(clang: clang)
  case CXCursor_Destructor: return Destructor(clang: clang)
  case CXCursor_ConversionFunction: return ConversionFunction(clang: clang)
  case CXCursor_TemplateTypeParameter: return TemplateTypeParameter(clang: clang)
  case CXCursor_NonTypeTemplateParameter: return NonTypeTemplateParameter(clang: clang)
  case CXCursor_TemplateTemplateParameter: return TemplateTemplateParameter(clang: clang)
  case CXCursor_FunctionTemplate: return FunctionTemplate(clang: clang)
  case CXCursor_ClassTemplate: return ClassTemplate(clang: clang)
  case CXCursor_ClassTemplatePartialSpecialization: return ClassTemplatePartialSpecialization(clang: clang)
  case CXCursor_NamespaceAlias: return NamespaceAlias(clang: clang)
  case CXCursor_UsingDirective: return UsingDirective(clang: clang)
  case CXCursor_UsingDeclaration: return UsingDeclaration(clang: clang)
  case CXCursor_TypeAliasDecl: return TypeAliasDecl(clang: clang)
  case CXCursor_ObjCSynthesizeDecl: return ObjCSynthesizeDecl(clang: clang)
  case CXCursor_ObjCDynamicDecl: return ObjCDynamicDecl(clang: clang)
  case CXCursor_CXXAccessSpecifier: return CXXAccessSpecifier(clang: clang)
  case CXCursor_ObjCSuperClassRef: return ObjCSuperClassRef(clang: clang)
  case CXCursor_ObjCProtocolRef: return ObjCProtocolRef(clang: clang)
  case CXCursor_ObjCClassRef: return ObjCClassRef(clang: clang)
  case CXCursor_TypeRef: return TypeRef(clang: clang)
  case CXCursor_CXXBaseSpecifier: return CXXBaseSpecifier(clang: clang)
  case CXCursor_TemplateRef: return TemplateRef(clang: clang)
  case CXCursor_NamespaceRef: return NamespaceRef(clang: clang)
  case CXCursor_MemberRef: return MemberRef(clang: clang)
  case CXCursor_LabelRef: return LabelRef(clang: clang)
  case CXCursor_OverloadedDeclRef: return OverloadedDeclRef(clang: clang)
  case CXCursor_VariableRef: return VariableRef(clang: clang)
  case CXCursor_InvalidFile: return InvalidFile(clang: clang)
  case CXCursor_NoDeclFound: return NoDeclFound(clang: clang)
  case CXCursor_NotImplemented: return NotImplemented(clang: clang)
  case CXCursor_InvalidCode: return InvalidCode(clang: clang)
  case CXCursor_UnexposedExpr: return UnexposedExpr(clang: clang)
  case CXCursor_DeclRefExpr: return DeclRefExpr(clang: clang)
  case CXCursor_MemberRefExpr: return MemberRefExpr(clang: clang)
  case CXCursor_CallExpr: return CallExpr(clang: clang)
  case CXCursor_ObjCMessageExpr: return ObjCMessageExpr(clang: clang)
  case CXCursor_BlockExpr: return BlockExpr(clang: clang)
  case CXCursor_IntegerLiteral: return IntegerLiteral(clang: clang)
  case CXCursor_FloatingLiteral: return FloatingLiteral(clang: clang)
  case CXCursor_ImaginaryLiteral: return ImaginaryLiteral(clang: clang)
  case CXCursor_StringLiteral: return StringLiteral(clang: clang)
  case CXCursor_CharacterLiteral: return CharacterLiteral(clang: clang)
  case CXCursor_ParenExpr: return ParenExpr(clang: clang)
  case CXCursor_UnaryOperator: return UnaryOperator(clang: clang)
  case CXCursor_ArraySubscriptExpr: return ArraySubscriptExpr(clang: clang)
  case CXCursor_BinaryOperator: return BinaryOperator(clang: clang)
  case CXCursor_CompoundAssignOperator: return CompoundAssignOperator(clang: clang)
  case CXCursor_ConditionalOperator: return ConditionalOperator(clang: clang)
  case CXCursor_CStyleCastExpr: return CStyleCastExpr(clang: clang)
  case CXCursor_CompoundLiteralExpr: return CompoundLiteralExpr(clang: clang)
  case CXCursor_InitListExpr: return InitListExpr(clang: clang)
  case CXCursor_AddrLabelExpr: return AddrLabelExpr(clang: clang)
  case CXCursor_StmtExpr: return StmtExpr(clang: clang)
  case CXCursor_GenericSelectionExpr: return GenericSelectionExpr(clang: clang)
  case CXCursor_GNUNullExpr: return GNUNullExpr(clang: clang)
  case CXCursor_CXXStaticCastExpr: return CXXStaticCastExpr(clang: clang)
  case CXCursor_CXXDynamicCastExpr: return CXXDynamicCastExpr(clang: clang)
  case CXCursor_CXXReinterpretCastExpr: return CXXReinterpretCastExpr(clang: clang)
  case CXCursor_CXXConstCastExpr: return CXXConstCastExpr(clang: clang)
  case CXCursor_CXXFunctionalCastExpr: return CXXFunctionalCastExpr(clang: clang)
  case CXCursor_CXXTypeidExpr: return CXXTypeidExpr(clang: clang)
  case CXCursor_CXXBoolLiteralExpr: return CXXBoolLiteralExpr(clang: clang)
  case CXCursor_CXXNullPtrLiteralExpr: return CXXNullPtrLiteralExpr(clang: clang)
  case CXCursor_CXXThisExpr: return CXXThisExpr(clang: clang)
  case CXCursor_CXXThrowExpr: return CXXThrowExpr(clang: clang)
  case CXCursor_CXXNewExpr: return CXXNewExpr(clang: clang)
  case CXCursor_CXXDeleteExpr: return CXXDeleteExpr(clang: clang)
  case CXCursor_UnaryExpr: return UnaryExpr(clang: clang)
  case CXCursor_ObjCStringLiteral: return ObjCStringLiteral(clang: clang)
  case CXCursor_ObjCEncodeExpr: return ObjCEncodeExpr(clang: clang)
  case CXCursor_ObjCSelectorExpr: return ObjCSelectorExpr(clang: clang)
  case CXCursor_ObjCProtocolExpr: return ObjCProtocolExpr(clang: clang)
  case CXCursor_ObjCBridgedCastExpr: return ObjCBridgedCastExpr(clang: clang)
  case CXCursor_PackExpansionExpr: return PackExpansionExpr(clang: clang)
  case CXCursor_SizeOfPackExpr: return SizeOfPackExpr(clang: clang)
  case CXCursor_LambdaExpr: return LambdaExpr(clang: clang)
  case CXCursor_ObjCBoolLiteralExpr: return ObjCBoolLiteralExpr(clang: clang)
  case CXCursor_ObjCSelfExpr: return ObjCSelfExpr(clang: clang)
  case CXCursor_OMPArraySectionExpr: return OMPArraySectionExpr(clang: clang)
  case CXCursor_ObjCAvailabilityCheckExpr: return ObjCAvailabilityCheckExpr(clang: clang)
  case CXCursor_UnexposedStmt: return UnexposedStmt(clang: clang)
  case CXCursor_LabelStmt: return LabelStmt(clang: clang)
  case CXCursor_CompoundStmt: return CompoundStmt(clang: clang)
  case CXCursor_CaseStmt: return CaseStmt(clang: clang)
  case CXCursor_DefaultStmt: return DefaultStmt(clang: clang)
  case CXCursor_IfStmt: return IfStmt(clang: clang)
  case CXCursor_SwitchStmt: return SwitchStmt(clang: clang)
  case CXCursor_WhileStmt: return WhileStmt(clang: clang)
  case CXCursor_DoStmt: return DoStmt(clang: clang)
  case CXCursor_ForStmt: return ForStmt(clang: clang)
  case CXCursor_GotoStmt: return GotoStmt(clang: clang)
  case CXCursor_IndirectGotoStmt: return IndirectGotoStmt(clang: clang)
  case CXCursor_ContinueStmt: return ContinueStmt(clang: clang)
  case CXCursor_BreakStmt: return BreakStmt(clang: clang)
  case CXCursor_ReturnStmt: return ReturnStmt(clang: clang)
  case CXCursor_GCCAsmStmt: return GCCAsmStmt(clang: clang)
  case CXCursor_AsmStmt: return AsmStmt(clang: clang)
  case CXCursor_ObjCAtTryStmt: return ObjCAtTryStmt(clang: clang)
  case CXCursor_ObjCAtCatchStmt: return ObjCAtCatchStmt(clang: clang)
  case CXCursor_ObjCAtFinallyStmt: return ObjCAtFinallyStmt(clang: clang)
  case CXCursor_ObjCAtThrowStmt: return ObjCAtThrowStmt(clang: clang)
  case CXCursor_ObjCAtSynchronizedStmt: return ObjCAtSynchronizedStmt(clang: clang)
  case CXCursor_ObjCAutoreleasePoolStmt: return ObjCAutoreleasePoolStmt(clang: clang)
  case CXCursor_ObjCForCollectionStmt: return ObjCForCollectionStmt(clang: clang)
  case CXCursor_CXXCatchStmt: return CXXCatchStmt(clang: clang)
  case CXCursor_CXXTryStmt: return CXXTryStmt(clang: clang)
  case CXCursor_CXXForRangeStmt: return CXXForRangeStmt(clang: clang)
  case CXCursor_SEHTryStmt: return SEHTryStmt(clang: clang)
  case CXCursor_SEHExceptStmt: return SEHExceptStmt(clang: clang)
  case CXCursor_SEHFinallyStmt: return SEHFinallyStmt(clang: clang)
  case CXCursor_MSAsmStmt: return MSAsmStmt(clang: clang)
  case CXCursor_NullStmt: return NullStmt(clang: clang)
  case CXCursor_DeclStmt: return DeclStmt(clang: clang)
  case CXCursor_OMPParallelDirective: return OMPParallelDirective(clang: clang)
  case CXCursor_OMPSimdDirective: return OMPSimdDirective(clang: clang)
  case CXCursor_OMPForDirective: return OMPForDirective(clang: clang)
  case CXCursor_OMPSectionsDirective: return OMPSectionsDirective(clang: clang)
  case CXCursor_OMPSectionDirective: return OMPSectionDirective(clang: clang)
  case CXCursor_OMPSingleDirective: return OMPSingleDirective(clang: clang)
  case CXCursor_OMPParallelForDirective: return OMPParallelForDirective(clang: clang)
  case CXCursor_OMPParallelSectionsDirective: return OMPParallelSectionsDirective(clang: clang)
  case CXCursor_OMPTaskDirective: return OMPTaskDirective(clang: clang)
  case CXCursor_OMPMasterDirective: return OMPMasterDirective(clang: clang)
  case CXCursor_OMPCriticalDirective: return OMPCriticalDirective(clang: clang)
  case CXCursor_OMPTaskyieldDirective: return OMPTaskyieldDirective(clang: clang)
  case CXCursor_OMPBarrierDirective: return OMPBarrierDirective(clang: clang)
  case CXCursor_OMPTaskwaitDirective: return OMPTaskwaitDirective(clang: clang)
  case CXCursor_OMPFlushDirective: return OMPFlushDirective(clang: clang)
  case CXCursor_SEHLeaveStmt: return SEHLeaveStmt(clang: clang)
  case CXCursor_OMPOrderedDirective: return OMPOrderedDirective(clang: clang)
  case CXCursor_OMPAtomicDirective: return OMPAtomicDirective(clang: clang)
  case CXCursor_OMPForSimdDirective: return OMPForSimdDirective(clang: clang)
  case CXCursor_OMPParallelForSimdDirective: return OMPParallelForSimdDirective(clang: clang)
  case CXCursor_OMPTargetDirective: return OMPTargetDirective(clang: clang)
  case CXCursor_OMPTeamsDirective: return OMPTeamsDirective(clang: clang)
  case CXCursor_OMPTaskgroupDirective: return OMPTaskgroupDirective(clang: clang)
  case CXCursor_OMPCancellationPointDirective: return OMPCancellationPointDirective(clang: clang)
  case CXCursor_OMPCancelDirective: return OMPCancelDirective(clang: clang)
  case CXCursor_OMPTargetDataDirective: return OMPTargetDataDirective(clang: clang)
  case CXCursor_OMPTaskLoopDirective: return OMPTaskLoopDirective(clang: clang)
  case CXCursor_OMPTaskLoopSimdDirective: return OMPTaskLoopSimdDirective(clang: clang)
  case CXCursor_OMPDistributeDirective: return OMPDistributeDirective(clang: clang)
  case CXCursor_OMPTargetEnterDataDirective: return OMPTargetEnterDataDirective(clang: clang)
  case CXCursor_OMPTargetExitDataDirective: return OMPTargetExitDataDirective(clang: clang)
  case CXCursor_OMPTargetParallelDirective: return OMPTargetParallelDirective(clang: clang)
  case CXCursor_OMPTargetParallelForDirective: return OMPTargetParallelForDirective(clang: clang)
  case CXCursor_OMPTargetUpdateDirective: return OMPTargetUpdateDirective(clang: clang)
  case CXCursor_OMPDistributeParallelForDirective: return OMPDistributeParallelForDirective(clang: clang)
  case CXCursor_OMPDistributeParallelForSimdDirective: return OMPDistributeParallelForSimdDirective(clang: clang)
  case CXCursor_OMPDistributeSimdDirective: return OMPDistributeSimdDirective(clang: clang)
  case CXCursor_OMPTargetParallelForSimdDirective: return OMPTargetParallelForSimdDirective(clang: clang)
  case CXCursor_TranslationUnit: return TranslationUnitCursor(clang: clang)
  case CXCursor_UnexposedAttr: return UnexposedAttr(clang: clang)
  case CXCursor_IBActionAttr: return IBActionAttr(clang: clang)
  case CXCursor_IBOutletAttr: return IBOutletAttr(clang: clang)
  case CXCursor_IBOutletCollectionAttr: return IBOutletCollectionAttr(clang: clang)
  case CXCursor_CXXFinalAttr: return CXXFinalAttr(clang: clang)
  case CXCursor_CXXOverrideAttr: return CXXOverrideAttr(clang: clang)
  case CXCursor_AnnotateAttr: return AnnotateAttr(clang: clang)
  case CXCursor_AsmLabelAttr: return AsmLabelAttr(clang: clang)
  case CXCursor_PackedAttr: return PackedAttr(clang: clang)
  case CXCursor_PureAttr: return PureAttr(clang: clang)
  case CXCursor_ConstAttr: return ConstAttr(clang: clang)
  case CXCursor_NoDuplicateAttr: return NoDuplicateAttr(clang: clang)
  case CXCursor_CUDAConstantAttr: return CUDAConstantAttr(clang: clang)
  case CXCursor_CUDADeviceAttr: return CUDADeviceAttr(clang: clang)
  case CXCursor_CUDAGlobalAttr: return CUDAGlobalAttr(clang: clang)
  case CXCursor_CUDAHostAttr: return CUDAHostAttr(clang: clang)
  case CXCursor_CUDASharedAttr: return CUDASharedAttr(clang: clang)
  case CXCursor_VisibilityAttr: return VisibilityAttr(clang: clang)
  case CXCursor_DLLExport: return DLLExport(clang: clang)
  case CXCursor_DLLImport: return DLLImport(clang: clang)
  case CXCursor_PreprocessingDirective: return PreprocessingDirective(clang: clang)
  case CXCursor_MacroDefinition: return MacroDefinition(clang: clang)
  case CXCursor_MacroExpansion: return MacroExpansion(clang: clang)
  case CXCursor_MacroInstantiation: return MacroInstantiation(clang: clang)
  case CXCursor_InclusionDirective: return InclusionDirective(clang: clang)
  case CXCursor_ModuleImportDecl: return ModuleImportDecl(clang: clang)
  case CXCursor_TypeAliasTemplateDecl: return TypeAliasTemplateDecl(clang: clang)
  case CXCursor_StaticAssert: return StaticAssert(clang: clang)
  case CXCursor_FriendDecl: return FriendDecl(clang: clang)
  case CXCursor_OverloadCandidate: return OverloadCandidate(clang: clang)
  default: fatalError("invalid CXCursorKind \(clang)")
  }
}
